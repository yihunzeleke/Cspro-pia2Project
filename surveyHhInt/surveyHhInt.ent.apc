{Application 'SURVEYHHINT' logic file generated by CSPro}
PROC GLOBAL
	// ***USER DEFINED VARIABLES***	
	array string distCodes(99);
	array string distLabels(99);
	array string vilCodes(99);
	array string vilLabels(99);
	array string eaCodes(99);
	array string eaLabels(99);
	array string hhMemberCodes(99);
	array string hhMemberNames(99);
	list string dbFileLoc;
	string mTabletCases;
	string confTabletCases;
	string reassignTabletCases;
	string adjustedPath;

	// ***USER DEFINED FUNCTIONS***
	//CLEAR ARRAY BEFORE RE-USE
	function clearStringArray(array string ar)
		numeric i = 1;
		while i < length(ar) do
			ar(i) = "";
			i = i + 1;
		enddo;
	end;

	//CHECK GEOVAR VALUE LIST ARRAY FOR EXISTING VALUES
	//0 = NOT FOUND, 1 = FOUND
	function arrayUnqCheck(array string ar, alpha val)
		numeric foundFlag = 0;
		do varying numeric i = 1 until foundFlag = 1 or i = length(ar, 1)
			if ar(i) = val then
				foundFlag = 1;
			endif;
		enddo;
		arrayUnqCheck = foundFlag;
	end;

	//RETURN ERROR MESSAGE IF RESPONSE IS NOT SUPPLIED
	function reqCheck(alpha val)
		if val = "" then
			errmsg("A value must be entered before you can proceed.");
			reenter;
		endif;
	end;

	// FIND DATE AND TIME. FORMAT: YYYYMMDD HH:MM:SS
	function string FindDateTime()
		string startTime = edit("99:99:99",systime());
		string startDate = edit("99999999",sysdate("YYYYMMDD"));
		FindDateTime = startDate + " " + startTime;
	end;
	
	//SET CASE LIST LABEL FOR IND INT CASES SOURCED FROM HUB
	function string hubCaseLabelSet(string sentId, string sentName, numeric sentAge, numeric sentSex)
		string tempMemId;
		string tempName;
		string tempAge;
		string tempSex;

		if strip(sentId) <> "" then
			tempMemID = strip(sentId);
		else
			tempMemId = "No ID entered";
		endif;

		if strip(sentName) <> "" then
			tempName = strip(sentName);
		else
			tempName = "No name entered";
		endif;

		if sentAge <> notappl then
			string ageString = edit("ZZ9", sentAge);
			if ageString[1:1] = " " then
				tempAge = ageString[2];
			else
				tempAge = ageString;
			endif;
		else
			tempAge = "No age entered";
		endif;

		if sentSex <> notappl then
			tempSex = getlabel(SURV_HUB_SEX_VS1, sentSex);
		else
			tempSex = "No sex entered";
		endif;

		hubCaseLabelSet = maketext("%s - %s (AGE: %s); SEX %s (NOT SYNCED)", tempMemId, tempName, tempAge, tempSex)
	end;

	//LAUNCH ROSTER FORM IN MODIFY MODE
	function launchHhRoster(numeric launchType)

		string rosterPffName = "..\surveyHhRstr\surveyHhRstr.pff";
		
		file rosterPff;
		if setfile(rosterPff, rosterPffName, create) = 0 then
			errmsg("Failed to open %s", rosterPffName);
		endif;
		
		filewrite(rosterPff, "[Run Information]");
		filewrite(rosterPff, "Version=CSPro 7.2");
		filewrite(rosterPff, "AppType=Entry");
		filewrite(rosterPff, "Description=Household Roster");
	
		filewrite(rosterPff, "[DataEntryInit]");
		if launchType = 1 then
			filewrite(rosterPff, "StartMode=Add");
		elseif launchType = 2 then
			filewrite(rosterPff, "StartMode=Modify");
		endif;
		filewrite(rosterPff, "Lock=Verify");
		filewrite(rosterPff, "AutoAdd=No");
		filewrite(rosterPff, "ShowInApplicationListing=Never");
		filewrite(rosterPff, "CaseListingFilter=^%s.*", concat(HHI_PROVINCE, HHI_DISTRICT, HHI_VILLAGE, HHI_EACODE, HHI_SHH, HHI_TEAM_ID));
	
		filewrite(rosterPff, "[Files]");
		filewrite(rosterPff, "Application=.\surveyHhRstr.ent");
		filewrite(rosterPff, "InputData=.\surveyHhRstr.csdb|CSPRODB");
		filewrite(rosterPff, "Paradata=.\surveyHhRstr.cslog");
	
		filewrite(rosterPff, "[ExternalFiles]");
		filewrite(rosterPff, "TM_HH_RSTR_MIN_DICT=..\surveyHhRstrMin\surveyHhRstrMin.csdb|CSPRODB");
		filewrite(rosterPff, "TM_IND_INT_DICT=..\surveyIndInt\surveyIndInt.csdb|CSPRODB");
		filewrite(rosterPff, "TM_SURV_DATA_HUB_DICT=..\shared\tmSurveyDataHub.csdb|CSPRODB");
		filewrite(rosterPff, "TM_HH_MEM_PASS_DICT=..\shared\tmHhMemPass.csdb|CSPRODB");
	
		filewrite(rosterPff, "[Parameters]");
		filewrite(rosterPff, "OnExit=..\surveyHhInt\surveyHhInt.pff");
		filewrite(rosterPff, "HHI_PROVINCE_PASS=%s", HHI_PROVINCE);
		filewrite(rosterPff, "HHI_DISTRICT_PASS=%s", HHI_DISTRICT);
		filewrite(rosterPff, "HHI_VILLAGE_PASS=%s", HHI_VILLAGE);
		filewrite(rosterPff, "HHI_EACODE_PASS=%s", HHI_EACODE);
		filewrite(rosterPff, "HHI_SHH_PASS=%s", HHI_SHH);
		filewrite(rosterPff, "HHI_TEAM_ID_PASS=%s", HHI_TEAM_ID);
		filewrite(rosterPff, "HHI_STRTDT_PASS=%s", SURVEYFORMSDT); //pass LISTINGFORMSDT  to subsections
		filewrite(rosterPff, "HHI_EA_UUID_PASS=%s", HHI_UUID);
		filewrite(rosterPff, "HHI_EA_DEVICEID_PASS=%s",HHI_DEVICEID);

		close(rosterPff);
	 
	 	//Launch modified pff
		execpff("..\surveyHhRstr\surveyHhRstr.pff", stop);
	end;

	//LAUNCH MINOR ROSTER FORM IN MODIFY MODE
	function launchMinRoster()

		string minRosterPffName = "..\surveyHhRstrMin\surveyHhRstrMin.pff";
		
		file minRosterPff;
		if setfile(minRosterPff, minRosterPffName, create) = 0 then
			errmsg("Failed to open %s", minRosterPffName);
		endif;
		
		filewrite(minRosterPff, "[Run Information]");
		filewrite(minRosterPff, "Version=CSPro 7.2");
		filewrite(minRosterPff, "AppType=Entry");
		filewrite(minRosterPff, "Description=Household Minor Roster");
	
		filewrite(minRosterPff, "[DataEntryInit]");
		filewrite(minRosterPff, "StartMode=Modify");
		filewrite(minRosterPff, "Lock=Verify, Add");
		filewrite(minRosterPff, "AutoAdd=No");
		filewrite(minRosterPff, "ShowInApplicationListing=Never");
		filewrite(minRosterPff, "CaseListingFilter=^%s.*", concat(HHI_PROVINCE, HHI_DISTRICT, HHI_VILLAGE, HHI_EACODE, HHI_SHH, HHI_TEAM_ID));
	
		filewrite(minRosterPff, "[Files]");
		filewrite(minRosterPff, "Application=.\surveyHhRstrMin.ent");
		filewrite(minRosterPff, "InputData=.\surveyHhRstrMin.csdb|CSPRODB");
		filewrite(minRosterPff, "Paradata=.\surveyHhRstrMin.cslog");
	
		filewrite(minRosterPff, "[ExternalFiles]");
		filewrite(minRosterPff, "TM_HH_RSTR_DICT=..\surveyHhRstr\surveyHhRstr.csdb|CSPRODB");

		filewrite(minRosterPff, "[Parameters]");
		filewrite(minRosterPff, "OnExit=..\surveyHhInt\surveyHhInt.pff");
		filewrite(minRosterPff, "HHRM_EA_DEVICEID_PASS=%s",HHI_DEVICEID);

		close(minRosterPff);
	 
	 	//Launch modified pff
		execpff("..\surveyHhRstrMin\surveyHhRstrMin.pff", stop);
	end;

	//LAUNCH INDIV INT FORM IN MODIFY MODE
	function launchIndInt()

		string indIntPffName = "..\surveyIndInt\surveyIndInt.pff";
		
		file indIntPff;
		if setfile(indIntPff, indIntPffName, create) = 0 then
			errmsg("Failed to open %s", indIntPffName);
		endif;
		
		filewrite(indIntPff, "[Run Information]");
		filewrite(indIntPff, "Version=CSPro 7.2");
		filewrite(indIntPff, "AppType=Entry");
		filewrite(indIntPff, "Description=Individual Interview");
	
		filewrite(indIntPff, "[DataEntryInit]");
		filewrite(indIntPff, "StartMode=Modify");
		filewrite(indIntPff, "Lock=Verify, Add");
		filewrite(indIntPff, "AutoAdd=No");
		filewrite(indIntPff, "ShowInApplicationListing=Never");
		filewrite(indIntPff, "CaseListingFilter=^%s.*", concat(HHI_PROVINCE, HHI_DISTRICT, HHI_VILLAGE, HHI_EACODE, HHI_SHH, HHI_TEAM_ID));
	
		filewrite(indIntPff, "[Files]");
		filewrite(indIntPff, "Application=.\surveyIndInt.ent");
		filewrite(indIntPff, "InputData=.\surveyIndInt.csdb|CSPRODB");
		filewrite(indIntPff, "Paradata=.\surveyIndInt.cslog");
	
		filewrite(indIntPff, "[ExternalFiles]");
		filewrite(indIntPff, "TM_SURV_DATA_HUB_DICT=..\shared\tmSurveyDataHub.csdb|CSPRODB");
		filewrite(indIntPff, "TM_HH_MEM_PASS_DICT=..\shared\tmHhMemPass.csdb|CSPRODB");
		filewrite(indIntPff, "TM_BARCODES_DICT=..\shared\tmBarcodesScans.csdb|CSPRODB");
		filewrite(indIntPff, "TM_SURVEYSIG_DICT=..\shared\tmSurveySignatures.csdb|CSPRODB");
	
		filewrite(indIntPff, "[Parameters]");
		filewrite(indIntPff, "OnExit=..\surveyHhInt\surveyHhInt.pff");
		filewrite(indIntPff, "IND_EA_DEVICEID_PASS=%s",HHI_DEVICEID);

		close(indIntPff);
	 
	 	//Launch modified pff
		execpff("..\surveyIndInt\surveyIndInt.pff", stop);
	end;

	//UPDATE HH INT FOR EXIT/RETURN FROM LOWER LEVEL
	function relaunchHhInt(alpha purpose)

		string hhIntPffName = "..\surveyHhInt\surveyHhInt.pff";
		
		file hhIntPff;
		if setfile(hhIntPff, hhIntPffName, create) = 0 then
			errmsg("Failed to open %s", hhIntPffName);
		endif;
		
		filewrite(hhIntPff, "[Run Information]");
		filewrite(hhIntPff, "Version=CSPro 7.2");
		filewrite(hhIntPff, "AppType=Entry");
		filewrite(hhIntPff, "Description=PHIA 2 Survey Template");
	
		filewrite(hhIntPff, "[DataEntryInit]");
		if purpose = "exit" then
			filewrite(hhIntPff, "StartMode=Modify");
		elseif purpose = "return" then
			filewrite(hhIntPff, "StartMode=Modify;%s", concat(HHI_PROVINCE, HHI_DISTRICT, HHI_VILLAGE, HHI_EACODE, HHI_SHH, HHI_TEAM_ID));
		endif;
		filewrite(hhIntPff, "Lock=Verify, Add");
		filewrite(hhIntPff, "AutoAdd=No");
		filewrite(hhIntPff, "ShowInApplicationListing=Never");
		filewrite(hhIntPff, "Interactive=Ask");
	
		filewrite(hhIntPff, "[Files]");
		filewrite(hhIntPff, "Application=.\surveyHhInt.ent");
		filewrite(hhIntPff, "InputData=.\surveyHhInt.csdb|CSPRODB");
		filewrite(hhIntPff, "Paradata=.\surveyHhInt.cslog");
	
		filewrite(hhIntPff, "[ExternalFiles]");
		filewrite(hhIntPff, "TM_SURV_GEOVARS_DICT=..\shared\tmSurveyGeovars.csdb|CSPRODB");
		filewrite(hhIntPff, "TM_SURV_DATA_HUB_DICT=..\shared\tmSurveyDataHub.csdb|CSPRODB");
		filewrite(hhIntPff, "TM_IND_INT_DICT=..\surveyIndInt\surveyIndInt.csdb|CSPRODB");
		filewrite(hhIntPff, "TM_SURVEYSIG_DICT=..\shared\tmSurveySignatures.csdb|CSPRODB");
		filewrite(hhIntPff, "TM_HH_MEM_PASS_DICT=..\shared\tmHhMemPass.csdb|CSPRODB");
	
		filewrite(hhIntPff, "[Parameters]");
		filewrite(hhIntPff, "OnExit=..\surveyMenu\surveyMenu.pff");

		close(hhIntPff);
	 
	 	//Launch modified pff
		//execpff("..\surveyHhRstrMin\surveyHhRstrMin.pff", stop);
	end;

	function extCapture(string mode, string prefix)
		
		//CREATE UUID FOR LINKING SIG BETWEEN APPS
		string extLink = uuid();
		string extRequestName = "/sdcard/csentry/temp/external_tool_info.txt";
		string outputFileName = "/sdcard/csentry/temp/phia-android-results";
		string fullOutputFileName = outputFileName + ".txt";
		string line;
		numeric runStatus;
		
		//DELETE PREVIOUS FILE
		filedelete(pathname(cspro) + "temp/phia-android-results.txt");

		//WRITE PARAMETERS FOR CAPTURE APP TO READ
		file extRequest;
		if setfile(extRequest, extRequestName, create) = 0 then
			errmsg("Failed to open %s", extRequestName);
		endif;
		filewrite(extRequest,"Guid=%s", extLink);
		//filewrite(extRequest, "CompleteDatabasePath=%s", dbFileString); //DELETE IF TEXT READ WORKS
		filewrite(extRequest, "OperationToExecute=%s", mode);
		if mode = "signature_capture" then
			filewrite(extRequest, "SignatureFileName=%s", prefix);
		endif;
		filewrite(extRequest, "OutputFilePath=%s", outputFileName);
	
		close(extRequest);

		execsystem("app:com.westat.PHIA_App");
	end;

	//READ RESULTS OF EXTERNAL APP RUN
	function string extRead(string mode);
		string outputFileName = "/sdcard/csentry/temp/phia-android-results";
		string fullOutputFileName = outputFileName + ".txt";
		string line;
		string capturePass;

		if mode = "signature_capture" then
			numeric i = 1;
			clear(TM_SURVEYSIG_DICT);
	
			file outputFile;
			if setfile(outputFile, fullOutputFileName, update) = 0 then
				errmsg("Failed to open %s", fullOutputFileName);
			endif;
			while fileread(outputFile, line) do
				if i = 1 then
					SS_RECID = line;
					i = i + 1;
				elseif i = 2 then
					SIGIMGNAME = line;
					capturePass = line;
					i = i + 1;
				else
					next;
				endif;
			enddo;
			SS_CASEID = HHI_UUID;
			SIGSYNCSTATUS = 1;
			writecase(TM_SURVEYSIG_DICT);	
			clear(TM_SURVEYSIG_DICT);
		{elseif mode = "barcode_scan" then
			clear(BARCODES_DICT);
			if loadcase(BARCODES_DICT, extLink) then
				capturePass = SIGIMGNAME;
			else
				capturePass = "Not Scanned";
			endif;}
		endif;
	extRead = capturePass;
	end;

//THIS TRIGGERED AN ERROR, PROBABLY NEEDS TO BE DELTED BUT SAVING UNTIL I KNOW MORE - JI 20190731
{PROC HHQINDIV
postproc
	if $ = 1 then
		savepartial();
		relaunchHhInt("return");
		launchIndInt();
	endif;}

	//BUILT IN FUNCTION TO OVERRIDE STOP FUNCTIONALITY, ELIMINATING PROMPTS

	function OnStop()
		if visualvalue(HHI_DE_START_FLAG) = 1 then
			savepartial();
		endif;
		relaunchHhInt("exit");
		execpff(".\surveyHhInt.pff", stop);
	end;

PROC SURVEYHHINT_FF

PROC TM_HH_INT_LEVEL

preproc
	adjustedPath = pathname(Application)[1:pos("/surveyHhInt/", pathname(Application))];

	//THIS IS TO RESET THE PFF FILE FOR NEXT USE EACH TIME DE RETURNS TO THIS FORM
	relaunchHhInt("exit");

	if demode() <> add and visualvalue(HHI_DE_START_FLAG) = 1 then
		if visualvalue(ROSTER_MENU) = 1 or visualvalue(ROSTER_MENU) = 2 then
			advance to ROSTER_MENU;
		elseif visualvalue(HHRINS31) = 2 then
			advance to HHRINS31;
		else
			advance to HHQENDCOPL;
		endif;
	endif;

	//RECORD HHINT UUID FOR RECORD LINKING
	if HHI_UUID = "" then
		HHI_UUID = uuid(TM_HH_INT_DICT);
	endif;	
	
	HHI_DEVICEID = getdeviceid();

PROC SURVEYHHINT_ADMIN_FORM

PROC SURVEYFORMSDT
	
preproc
	// DO NOT DISPLAY FORM START/DATE TIME ON TABLET
	noinput;
	
	
postproc
	// FIND START DATE AND TIME OF FORM THEN ADD TO DICTIONARY ITEM
	$ = FindDateTime();
PROC STAFFIDHH

postproc
	if $ <> "" then
		HHI_DE_START_FLAG = 1;
		setcaselabel(TM_HH_INT_DICT, maketext("EA - %s, Household %s (NOT SYNCED)", HHI_EACODE, HHI_SHH));
		relaunchHhInt("return");
	endif;
PROC HHCONF

postproc 
	if HHCONF = 2 then
		errmsg("Please use the back button to Discard Changes to this household and then select another household.");
		reenter;
	endif;
	
PROC STARTINT

postproc
	if STARTINT = 1 then
		skip to HHCINST1;
	endif;
	
PROC RESULTNDT

postproc
	if RESULTNDT <> 96 then
		skip to HHSINSHH;
	else
		advance to RESULTNDOTH;
	endif;
	
PROC HHCINST1
preproc
	$ = "A";
	
PROC HHESTART

preproc
	$ = "A";
	
PROC HHEHEARACM

preproc
	ask if HHEHEARING = 2;

postproc	
	if HHEHEARACM = 2 then
		skip to SURVEYHHINT_END_OF_CONSENT_FORM;
	endif;
	
PROC HHELANGACM

preproc
	ask if HHELANGACC = 2;

postproc
	if HHELANGACM = 2 then
		skip to SURVEYHHINT_END_OF_CONSENT_FORM;
	endif;
	
PROC HHEPARAG

preproc
	$ = "A";
	
PROC HHECOGN

postproc
	if HHECOGN = 2 then
		skip to SURVEYHHINT_END_OF_CONSENT_FORM;
	endif;
	
PROC HHAGEYEARS

postproc
	if HHAGEYEARS >= 18 then 
		skip to HHECONS;
	elseif HHAGEYEARS < 15 then
		skip to SURVEYHHINT_END_OF_CONSENT_FORM;
	endif;
	
PROC HHEMANCMINOR

postproc
	if HHEMANCMINOR = 2 then
		skip to SURVEYHHINT_END_OF_CONSENT_FORM;
	endif;
	
PROC HHECONS

preproc
	$ = "A";
	
PROC HHSSTART

preproc
	$ = "A";
	
PROC HHELANG

postproc
	if visualvalue(HHCAGREE) = notappl then
		if $ = 1 then
			execsystem("view:" + adjustedPath + "shared/consents/Template_Appendix B1_Consent_for_HH_Interview_tablet_r20190815.pdf")
		else
			warning("PDF consent not available for %s.", getvaluelabel($));
		endif;
	endif;
	
PROC HHCAGREE

postproc
	if HHCAGREE = 1 then
		advance to HHCAGRY;
	else 
		skip to HHCAGRN;
	endif;
	
PROC HHCAGRY

PREPROC
	ask if HHCAGREE = 1;
	
PROC HHCAGRN

PREPROC
	ask if HHCAGREE = 2;

postproc
	skip to SURVEYHHINT_END_OF_CONSENT_FORM;
PROC HHCCONFIRM
	if HHCCONFIRM = 2 then 
		errmsg("Please go back and correct the inaccurate response.");
		reenter;
	endif;
PROC HHCONNM
postproc
	if HHSTFSIG = "" then
		warning("Signature of person obtaining consent")
		select("Continue", continue, "Cancel", reenter);
		extCapture("signature_capture", "HHSTFSIG");
		warning("Verify signature")
		select("Continue",continue,"Recapture Signature",reenter);
	endif;
PROC HHSTFSIG
preproc
	$ = extRead("signature_capture");
PROC HHCEND

preproc
	$ = "A";
PROC HHCONSTAT

postproc 
	if HHCONSTAT = 3 then
		advance to INELIGTHX;
	endif;
PROC INELIGTHX
preproc
	ask if HHCONSTAT = 3;
	$ = "A";
	
PROC ROSTER_MENU
postproc
	if $ = 1 or $ = 2 then
		savepartial();
		relaunchHhInt("return");
		launchHhRoster($);
	endif;

PROC HHRINS31
postproc
	if $ = 2 then
		savepartial();
		relaunchHhInt("return");
		launchMinRoster();
	endif;

PROC HHQDTHSINS


preproc
	$ = 'A';
PROC DEATHS

postproc
	if DEATHS <> 1 then 
		skip to HHQINSHH;
	endif;
	
PROC DEATHCOUNT

	if DEATHCOUNT = 0 then
		errmsg("Participant reported that at least 1 person had died in the household.  Please correct the entry.");
		reenter;
	endif;
	
PROC SURVEYHHINT_DTH_IN_HHD000

preproc
	ask if DEATHCOUNT > 0;
PROC DIEDNAMEDKR

preproc
	ask if DIEDNAME = "";
PROC DIEDDATED

PROC BLOCK000

	setproperty(DIEDAGENUM, "CanEnterNotAppl","NoConfirm");
	setproperty(DIEDAGE, "CanEnterNotAppl","NoConfirm");
PROC DIEDAGE

postproc
	if DIEDAGENUM > 30 and DIEDAGE = 1 then
		errmsg("If age at death was greater than 30 days, please record in months or completed years.");
		reenter;
	endif;
	
	if DIEDAGENUM >= 12 and DIEDAGE = 2 then
		errmsg("If age at death was one completed year or more, please record in years.");
		reenter;
	endif;
	
	if DIEDAGENUM > 120 and DIEDAGE = 3 then
		errmsg("Age at death cannot be greater than 120 years. Please correct.");
		reenter;
	endif;
	

	if DIEDAGENUM <> notappl and DIEDAGE = notappl then
		errmsg("A valid unit of measuremnt is required if Age is provided.");
		reenter;
	endif;
	
PROC DIEDAGEDK

preproc
	ask if DIEDAGENUM = notappl
PROC HHQ

preproc	
	$ = 'A';
PROC HHQINSHH

preproc
	$ = "A";
PROC WATERSOURCE

	if WATERSOURCE <> 96 then
		skip to TOILETTYPE;
	endif;
	
PROC TOILETTYPE

	if TOILETTYPE = 61 or TOILETTYPE < 0 then
		skip to HHQITEMS;
	elseif TOILETTYPE = 11 or TOILETTYPE = 21 or TOILETTYPE = 22 then
		skip to TOILETSHARE;
	endif;
	
PROC TOILETTYPEOT

preproc
	ask if TOILETTYPE = 96;
PROC HHQITEMS

	if (pos('F',$) > 0 or pos('Y',$) > 0 or pos('Z',$) > 0) and length (strip($))>1  then
		errmsg ('"NONE OF THE ABOVE", "DON’T KNOW" AND "REFUSED" cannot be selected with any other category.');
  		$= "";
  		reenter;
	else
	endif;
PROC COOKINGFUEL

	if COOKINGFUEL <> 96 then
		skip to MATFLOOR;
	endif;
	
PROC MATFLOOR

	if MATFLOOR <> 96 then
		skip to MATROOF;
	endif;
	
PROC MATROOF

	if MATROOF <> 96 then
		skip to MATEXWALLS;
	endif;
	
PROC MATEXWALLS

	if MATEXWALLS <> 96 then
		skip to ROOMSLEEP;
	endif;
	
PROC ROOMSLEEP

	if ROOMSLEEP = 0 then
		errmsg("The number of rooms cannot be zero.");
		reenter;
	endif;
	
PROC HHQOWN


	if (pos('E',$) > 0 or pos('Y',$) > 0 or pos('Z',$) > 0) and length (strip($))>1  then
		errmsg ('"NONE OF THE ABOVE", "DON’T KNOW" AND "REFUSED" cannot be selected with any other category.');
  		$= "";
  		reenter;
	else
	endif;
PROC HHQOWN2G

setproperty(OWNCOWNUM, "CanEnterNotAppl","NoConfirm");
setproperty(OWNGOATNUM, "CanEnterNotAppl","NoConfirm");
setproperty(OWNCHIKNNUM, "CanEnterNotAppl","NoConfirm");
setproperty(OWNDOGNUM, "CanEnterNotAppl","NoConfirm");
setproperty(OWNHORSENUM, "CanEnterNotAppl","NoConfirm");


//possibly redo this section not as a block, check with DM.   Block structure prevents skip pattern and makes edits annoying. 
PROC HHQECOINS

preproc 
	$ = "A";
PROC ECONSUP12

//if pos("4", choice2) <> 0 then
postproc
	//DEFINE VALUES THAT CAN'T BE CHOSEN WITH OTHER VALUES
	array string singlesArray(3) = "A", "Y", "Z";

	//WALK THROUGH ARRAY OF SINGLES VALUES, CHECKING FOR SELECTION
	do varying numeric i = 1 until i > length(singlesArray)
		if pos(singlesArray(i), $) <> 0 and length(strip($)) > 1 then
			errmsg("'%s' cannot be selected with other values", getlabel($, singlesArray(I)));
			reenter;
		endif;
	enddo;

	//SKIP OTHER SPECIFY IF OTHER NOT CHOSEN
	if pos("X", $) = 0 then
		skip to HHQINSEND;
	endif;
	
PROC HHQINSEND

preproc
	$ = "A";
PROC HHQENDSUM

preproc
	$ = "A";
PROC HHQENDCOPL

preproc
	$ = "A";
PROC HHQASSIGN_INST

preproc
	$  = "A";
PROC HHQASSIGN

onfocus
	//Variables
	numeric i = 1;
	//Clear Codes/Labels arrays of previous values
	clearStringArray(hhMemberCodes);
	clearStringArray(hhMemberNames);
	
	forcase TM_SURV_DATA_HUB_DICT where SURV_HUB_PROVINCE = HHI_PROVINCE and SURV_HUB_DISTRICT = HHI_DISTRICT and SURV_HUB_VILLAGE = HHI_VILLAGE and 
	SURV_HUB_EACODE = HHI_EACODE and SURV_HUB_SHH = HHI_SHH and SURV_HUB_TEAM_ID = HHI_TEAM_ID do
		//Review codes array to see if the value has already been added
		numeric unqCheck = arrayUnqCheck(hhMemberCodes, SURV_HUB_HHMEM_ID);
		
		//If the value has not been added, add it to the arrays
		if unqCheck = 0 then
			hhMemberCodes(i) = SURV_HUB_HHMEM_ID;
			hhMemberNames(i) = concat(strip(SURV_HUB_HHMEM_ID), " - ", strip(SURV_HUB_NAME), ": ", getvaluelabel(SURV_HUB_STATUS));
			i = i + 1;
		endif;
	endfor;
	hhMemberCodes(i) = "";
	setvalueset($, hhMemberCodes, hhMemberNames);

postproc
	if $ = "" then
		skip to HHQINDIC;
	endif;


PROC HHQASSIGNCONFIRM

onfocus
	confTabletCases = "";
	numeric caseCount = 1;
	do varying numeric i = 1 until HHQASSIGN[i] = ""
		if i % 2 > 0 then
			string hhMem = HHQASSIGN[i:2];
			forcase TM_SURV_DATA_HUB_DICT where SURV_HUB_PROVINCE = HHI_PROVINCE and SURV_HUB_DISTRICT = HHI_DISTRICT and SURV_HUB_VILLAGE = HHI_VILLAGE and 
			SURV_HUB_EACODE = HHI_EACODE and SURV_HUB_SHH = HHI_SHH and SURV_HUB_TEAM_ID = HHI_TEAM_ID and SURV_HUB_HHMEM_ID = hhMem and (SURV_HUB_STATUS = 1 or SURV_HUB_STATUS = 3) do
				if caseCount = 1 then
					confTabletCases = concat(strip(SURV_HUB_HHMEM_ID), " - ", strip(SURV_HUB_NAME));
					caseCount = caseCount + 1;
				else
					confTabletCases = concat(confTabletCases, "<br><br>", concat(strip(SURV_HUB_HHMEM_ID), " - ", strip(SURV_HUB_NAME)));
					caseCount = caseCount + 1;
				endif;
			endfor;
		else
			next;
		endif;
	enddo;

PROC HHQTAPINST

postproc
	if $ = "A" then
		//HH MEM TRANSFER
		//CODES:
		//1 = CREATED, NOT TRANFERRED
		//2 = FLAGGED FOR TRANSFER (THIS SHOULD BE A TEMPORARY FLAG)
		//3 = TRANSFERRED/ASSIGNED TO AN ENUMERATOR
		numeric txFlag = 0;

		do varying numeric i = 1 until HHQASSIGN[i] = ""
			if i % 2 > 0 then
				string hhMem = HHQASSIGN[i:2];
				if loadcase(TM_SURV_DATA_HUB_DICT, HHI_PROVINCE, HHI_DISTRICT, HHI_VILLAGE, HHI_EACODE, HHI_SHH, HHI_TEAM_ID, hhMem) then
					SURV_HUB_STATUS_TS = FindDateTime();
					if SURV_HUB_STATUS = 1 then
						SURV_HUB_STATUS = 21;
					elseif SURV_HUB_STATUS = 3 then
						SURV_HUB_STATUS = 23;
					endif;
					writecase(TM_SURV_DATA_HUB_DICT);
					clear(TM_SURV_DATA_HUB_DICT);
					txFlag = 1;
				else
					errmsg("Could not find household member %s, case will not be transferred", hhMem);
				endif;
			else
				next;
			endif;
		enddo;

		numeric txCount = 0;
		if txFlag = 1 then
			if syncconnect(Bluetooth) then
				forcase TM_SURV_DATA_HUB_DICT where (SURV_HUB_STATUS = 21 or SURV_HUB_STATUS = 23) do
					syncdata(PUT ,TM_SURV_DATA_HUB_DICT, concat(SURV_HUB_PROVINCE, SURV_HUB_DISTRICT, SURV_HUB_VILLAGE, SURV_HUB_EACODE, SURV_HUB_SHH, SURV_HUB_TEAM_ID, SURV_HUB_HHMEM_ID));
					SURV_HUB_STATUS_TS = FindDateTime();
					SURV_HUB_STATUS = 3;
					writecase(TM_SURV_DATA_HUB_DICT);
					txCount = txCount + 1;
				endfor;
				syncdata(PUT, TM_HH_MEM_PASS_DICT);
				syncdisconnect();
				warning("%d records succesfully transferred.", txCount);
			else	
				warning("Connection could not be established or was interrupted, selected cases NOT transferred");
			endif;
		endif;
	endif;
PROC HHQTABSUCC
postproc
	if $ = 1 then
		HHQASSIGN = "";
		HHQASSIGNCONFIRM = "";
		HHQTAPINST = "";
		$ = notappl;
	elseif $ = 2 then
		forcase TM_SURV_DATA_HUB_DICT where SURV_HUB_STATUS = 21 do
			SURV_HUB_STATUS_TS = FindDateTime();
			//NOT SYNCED, REVERT TO CREATED NOT SYNCED STATUS
			SURV_HUB_STATUS = 1;
			writecase(TM_SURV_DATA_HUB_DICT);
		endfor;

		forcase TM_SURV_DATA_HUB_DICT where SURV_HUB_STATUS = 23 do
			SURV_HUB_STATUS_TS = FindDateTime();
			//NOT SYNCED, REVERT TO CREATED NOT SYNCED STATUS
			SURV_HUB_STATUS = 3;
			writecase(TM_SURV_DATA_HUB_DICT);
		endfor;
		errmsg("Please go back to the previous screen and repeat the tablet transfer (using the LAUNCH button) until all tablets have successfully completed the transfer.");
		$ = notappl;
		HHQTAPINST = "";
		reenter;
	endif;
PROC HHQINDIC

preproc
	ask if countcases(TM_SURV_DATA_HUB_DICT where SURV_HUB_PROVINCE = HHI_PROVINCE and SURV_HUB_DISTRICT = HHI_DISTRICT and SURV_HUB_VILLAGE = HHI_VILLAGE and 
	SURV_HUB_EACODE = HHI_EACODE and SURV_HUB_SHH = HHI_SHH and SURV_HUB_TEAM_ID = HHI_TEAM_ID and SURV_HUB_STATUS = 1) > 0;

onfocus
	mTabletCases = "";
	numeric caseCount = 1;
	forcase TM_SURV_DATA_HUB_DICT where SURV_HUB_PROVINCE = HHI_PROVINCE and SURV_HUB_DISTRICT = HHI_DISTRICT and SURV_HUB_VILLAGE = HHI_VILLAGE and 
	SURV_HUB_EACODE = HHI_EACODE and SURV_HUB_SHH = HHI_SHH and SURV_HUB_TEAM_ID = HHI_TEAM_ID and SURV_HUB_STATUS = 1 do
		if caseCount = 1 then
			mTabletCases = concat(strip(SURV_HUB_HHMEM_ID), " - ", strip(SURV_HUB_NAME));
			caseCount = caseCount + 1;
		else
			mTabletCases = concat(mTabletCases, "<br>", concat(strip(SURV_HUB_HHMEM_ID), " - ", strip(SURV_HUB_NAME)));
			caseCount = caseCount + 1;
		endif;
	endfor;
	
postproc
	if $ = 1 then
		forcase TM_SURV_DATA_HUB_DICT where SURV_HUB_PROVINCE = HHI_PROVINCE and SURV_HUB_DISTRICT = HHI_DISTRICT and SURV_HUB_VILLAGE = HHI_VILLAGE and 
		SURV_HUB_EACODE = HHI_EACODE and SURV_HUB_SHH = HHI_SHH and SURV_HUB_TEAM_ID = HHI_TEAM_ID and SURV_HUB_STATUS = 1 do
			//ADD HH MEMBER RECORD TO IND INT DICT IF IT DOESN'T ALREADY EXIST
			if countcases(TM_IND_INT_DICT where (IND_PROVINCE = SURV_HUB_PROVINCE and IND_DISTRICT = SURV_HUB_DISTRICT and IND_VILLAGE = SURV_HUB_VILLAGE and 
			IND_EACODE = SURV_HUB_EACODE and IND_SHH = SURV_HUB_SHH and IND_TEAM_ID = SURV_HUB_TEAM_ID and IND_HHMEM_ID = SURV_HUB_HHMEM_ID)) = 0 then 
				clear(TM_IND_INT_DICT);
				IND_PROVINCE = SURV_HUB_PROVINCE;
				IND_DISTRICT = SURV_HUB_DISTRICT;
				IND_VILLAGE = SURV_HUB_VILLAGE;
				IND_EACODE = SURV_HUB_EACODE;
				IND_SHH = SURV_HUB_SHH;
				IND_TEAM_ID = SURV_HUB_TEAM_ID;
				IND_HHMEM_ID = SURV_HUB_HHMEM_ID;
				IND_LISTINGFORMSDT = SURV_HUB_LISTINGFORMSDT;
				IND_HHI_UUID = SURV_HUB_HHI_UUID;
				setcaselabel(TM_IND_INT_DICT, hubCaseLabelSet(SURV_HUB_HHMEM_ID, SURV_HUB_NAME, SURV_HUB_AGE_YRS, SURV_HUB_SEX));
				writecase(TM_IND_INT_DICT);
				sqlquery(TM_IND_INT_DICT, maketext('update cases set partial_save_mode = 2, partial_save_field_name = "TM_IND_INT_LEVEL", partial_save_level_key = "", partial_save_record_occurrence=0, partial_save_item_occurrence=0, partial_save_subitem_occurrence=0 where key="%s";', 
				concat(SURV_HUB_PROVINCE, SURV_HUB_DISTRICT, SURV_HUB_VILLAGE, SURV_HUB_EACODE, SURV_HUB_SHH, SURV_HUB_TEAM_ID, SURV_HUB_HHMEM_ID)));
				SURV_HUB_STATUS_TS = FindDateTime();
				SURV_HUB_STATUS = 3;
				writecase(TM_SURV_DATA_HUB_DICT);
			endif;
		endfor;
		savepartial();
		launchIndInt();
		$ = notappl;
	endif;
	
	if $ = 2 and countcases(TM_SURV_DATA_HUB_DICT where SURV_HUB_PROVINCE = HHI_PROVINCE and SURV_HUB_DISTRICT = HHI_DISTRICT and SURV_HUB_VILLAGE = HHI_VILLAGE and 
	SURV_HUB_EACODE = HHI_EACODE and SURV_HUB_SHH = HHI_SHH and SURV_HUB_TEAM_ID = HHI_TEAM_ID and SURV_HUB_STATUS = 3) = 0 then
		errmsg("No previously assigned cases found.");
		reenter;
	endif;
PROC HHQREASSIGN
preproc
	ask if HHQINDIC = 2;


onfocus
	//Variables
	numeric i = 1;
	//Clear Codes/Labels arrays of previous values
	clearStringArray(hhMemberCodes);
	clearStringArray(hhMemberNames);
	
	forcase TM_SURV_DATA_HUB_DICT where SURV_HUB_PROVINCE = HHI_PROVINCE and SURV_HUB_DISTRICT = HHI_DISTRICT and SURV_HUB_VILLAGE = HHI_VILLAGE and 
	SURV_HUB_EACODE = HHI_EACODE and SURV_HUB_SHH = HHI_SHH and SURV_HUB_TEAM_ID = HHI_TEAM_ID and SURV_HUB_STATUS = 3 do
		//Review codes array to see if the value has already been added
		numeric unqCheck = arrayUnqCheck(hhMemberCodes, SURV_HUB_HHMEM_ID);
		
		//If the value has not been added, add it to the arrays
		if unqCheck = 0 then
			hhMemberCodes(i) = SURV_HUB_HHMEM_ID;
			hhMemberNames(i) = concat(strip(SURV_HUB_HHMEM_ID), " - ", strip(SURV_HUB_NAME), ": ", getvaluelabel(SURV_HUB_STATUS));
			i = i + 1;
		endif;
	endfor;
	hhMemberCodes(i) = "";
	setvalueset($, hhMemberCodes, hhMemberNames);

postproc
	
	if strip($) <> "" then
		reassignTabletCases = "";
		numeric caseCount = 1;
		do varying numeric j = 1 until $[j] = ""
			if j % 2 > 0 then
				string hhMem = $[j:2];
				forcase TM_SURV_DATA_HUB_DICT where SURV_HUB_PROVINCE = HHI_PROVINCE and SURV_HUB_DISTRICT = HHI_DISTRICT and SURV_HUB_VILLAGE = HHI_VILLAGE and 
				SURV_HUB_EACODE = HHI_EACODE and SURV_HUB_SHH = HHI_SHH and SURV_HUB_TEAM_ID = HHI_TEAM_ID and SURV_HUB_HHMEM_ID = hhMem and SURV_HUB_STATUS = 3 do
					SURV_HUB_STATUS_TS = FindDateTime();
					//NOT SYNCED, REVERT TO CREATED NOT SYNCED STATUS
					SURV_HUB_STATUS = 1;
					writecase(TM_SURV_DATA_HUB_DICT);
				endfor;
			endif;
		enddo;
		$ = "";
		move to HHQINDIC;
	else
		errmsg("Select at least one individual, or swipe back to cancel reassignment");
		reenter;
	endif;
